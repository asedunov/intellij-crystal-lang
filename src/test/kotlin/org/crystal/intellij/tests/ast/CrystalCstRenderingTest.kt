package org.crystal.intellij.tests.ast

import junit.framework.TestCase
import org.crystal.intellij.lang.ast.nodes.CstAssign
import org.crystal.intellij.lang.ast.nodes.CstExpressions
import org.crystal.intellij.lang.ast.nodes.CstNode
import org.crystal.intellij.lang.ast.render

class CrystalCstRenderingTest : CrystalCstParsingTestBase() {
    private fun String.check(expected: String = this) {
        convert(this).check(expected)
    }

    private fun CstNode.check(expected: String) {
        TestCase.assertEquals(expected, render())
    }

    fun testRendering() {
        "([] of T).foo".check()
        "({} of K => V).foo".check()
        "foo(bar)".check()
        "(~1).foo".check()
        "1 && (a = 2)".check()
        "(a = 2) && 1".check()
        "foo(a.as(Int32))".check()
        "(1 + 2).as(Int32)".check()
        "a.as?(Int32)".check()
        "(1 + 2).as?(Int32)".check()
        "@foo.bar".check()
        ":foo".check()
        ":\"{\"".check()
        "%r()".check()
        "%r()imx".check()
        "/hello world/".check()
        "/hello world/imx".check()
        "/\\s/".check()
        "/\\?/".check()
        "/\\(group\\)/".check()
        "/\\//".check()
        "/#{1 / 2}/".check()
        "%r(/)".check("/\\//")
        "/ /".check("/\\ /")
        "%r( )".check("/\\ /")
        "foo &.bar".check("foo(&.bar)")
        "foo &.bar(1, 2, 3)".check("foo(&.bar(1, 2, 3))")
        "foo x: 1, y: 2, &.bar".check("foo(x: 1, y: 2, &.bar)")
        "foo { |i| i.bar { i } }".check("foo do |i|\n  i.bar do\n    i\n  end\nend")
        "foo do |k, v|\n  k.bar(1, 2, 3)\nend".check()
        "foo(3, &.*(2))".check()
        "return begin\n  1\n  2\nend".check()
        "macro foo\n  %bar = 1\nend".check()
        "macro foo\n  %bar = 1; end".check()
        "macro foo\n  %bar{1, x} = 1\nend".check()
        "{% foo %}".check()
        "{{ foo }}".check()
        "{% if foo %}\n  foo_then\n{% end %}".check()
        "{% if foo %}\n  foo_then\n{% else %}\n  foo_else\n{% end %}".check()
        "{% for foo in bar %}\n  {{ foo }}\n{% end %}".check()
        "macro foo\n  {% for foo in bar %}\n    {{ foo }}\n  {% end %}\nend".check()
        "1.as(Int32)".check()
        "(1 || 1.1).as(Int32)".check("(1 || 1.1).as(Int32)")
        "1 & 2 & (3 | 4)".check("(1 & 2) & (3 | 4)")
        "(1 & 2) & (3 | 4)".check()
        "def foo(x : T = 1)\nend".check()
        "def foo(@[Foo] x : T = 1)\nend".check()
        "def foo(x : X, y : Y) forall X, Y\nend".check()
        "def foo(x : X, @[Foo] y : Y) forall X, Y\nend".check()
        "foo : A | (B -> C)".check()
        "foo : (A | B).class".check()
        "%(\"#{foo}\")".check("\"\\\"#{foo}\\\"\"")
        "class Foo\n  private def bar\n  end\nend".check()
        "foo(&.==(2))".check()
        "foo.nil?".check()
        "foo._bar".check()
        "foo._bar(1)".check()
        "_foo.bar".check()
        "1.responds_to?(:to_s)".check()
        "1.responds_to?(:\"&&\")".check()
        "macro foo(&block)\nend".check()
        "macro foo(&)\nend".check()
        "macro foo(*, __var var)\nend".check()
        "macro foo(*, var)\nend".check()
        "macro foo(*var)\nend".check()
        "macro foo(@[Foo] &)\nend".check()
        "macro foo(@[Foo] &block)\nend".check()
        "macro foo(x, *y)\nend".check()
        "macro foo(x, @[Foo] *y)\nend".check()
        "macro foo(@[Foo] x, @[Foo] *y)\nend".check()
        "{ {1, 2, 3} }".check()
        "{ {1 => 2} }".check()
        "{ {1, 2, 3} => 4 }".check()
        "{ {foo: 2} }".check()
        "def foo(*args)\nend".check()
        "def foo(@[Foo] *args)\nend".check()
        "def foo(*args : _)\nend".check()
        "def foo(**args)\nend".check()
        "def foo(@[Foo] **args)\nend".check()
        "def foo(**args : T)\nend".check()
        "def foo(x, **args)\nend".check()
        "def foo(x, @[Foo] **args)\nend".check()
        "def foo(x, **args, &block)\nend".check()
        "def foo(@[Foo] x, @[Bar] **args, @[Baz] &block)\nend".check()
        "def foo(x, **args, &block : (_ -> _))\nend".check()
        "def foo(& : (->))\nend".check()
        "macro foo(@[Foo] id)\nend".check()
        "macro foo(**args)\nend".check()
        "macro foo(@[Foo] **args)\nend".check()
        "macro foo(x, **args)\nend".check()
        "macro foo(x, @[Foo] **args)\nend".check()
        "def foo(x y)\nend".check()
        "def foo(@[Foo] x y)\nend".check()
        "foo(\"bar baz\": 2)".check()
        "Foo(\"bar baz\": Int32)".check()
        "Foo()".check()
        "{\"foo bar\": 1}".check()
        "def foo(\"bar baz\" qux)\nend".check()
        "foo()".check()
        "/a/x".check()
        "1_f32".check("1_f32")
        "1_f64".check("1_f64")
        "1.0".check("1.0")
        "1e10_f64".check("1e10")
        "!a".check()
        "!(1 < 2)".check()
        "(1 + 2)..3".check()
        "macro foo\n{{ @type }}\nend".check()
        "macro foo\n\\{{ @type }}\nend".check()
        "macro foo\n{% @type %}\nend".check()
        "macro foo\n\\{%@type %}\nend".check()
        "enum A : B\nend".check()
        "foo[x, y, a: 1, b: 2]".check()
        "foo[x, y, a: 1, b: 2] = z".check()
        "@[Foo(1, 2, a: 1, b: 2)]".check()
        "lib Foo\nend".check()
        "lib LibC\n  fun getchar(Int, Float)\nend".check()
        "fun foo(a : Void, b : Void, ...) : Void\n\nend".check()
        "lib Foo\n  struct Foo\n    a : Void\n    b : Void\n  end\nend".check()
        "lib Foo\n  union Foo\n    a : Int\n    b : Int32\n  end\nend".check()
        "lib Foo\n  FOO = 0\nend".check()
        "lib LibC\n  fun getch = \"get.char\"\nend".check()
        "lib Foo::Bar\nend".check()
        "enum Foo\n  A = 0\n  B\nend".check()
        "alias Foo = Void".check()
        "alias Foo::Bar = Void".check()
        "type(Foo = Void)".check()
        "return true ? 1 : 2".check()
        "1 <= 2 <= 3".check()
        "(1 <= 2) <= 3".check()
        "1 <= (2 <= 3)".check()
        "case 1; when .foo?; 2; end".check("case 1\nwhen .foo?\n  2\nend")
        "case 1; in .foo?; 2; end".check("case 1\nin .foo?\n  2\nend")
        "case 1; when .!; 2; when .< 0; 3; end".check("case 1\nwhen .!\n  2\nwhen .<(0)\n  3\nend")
        "case 1\nwhen .[](2)\n  3\nwhen .[]=(4)\n  5\nend".check()
        "{(1 + 2)}".check()
        "{foo: (1 + 2)}".check()
        "\"#{(1 + 2)}\"".check()
        "{(1 + 2) => (3 + 4)}".check()
        "[(1 + 2)] of Int32".check()
        "foo(1, (2 + 3), bar: (4 + 5))".check()
        "if (1 + 2\n3)\n  4\nend".check()
        "%x(whoami)".check("`whoami`")
        "begin\n  ()\nend".check()
        "if 1\n  begin\n    2\n  end\nelse\n  begin\n    3\n  end\nend".check()
        "foo do\n  begin\n    bar\n  end\nend".check()
        "foo.*".check()
        "foo.%".check()
        "&+1".check()
        "&-1".check()
        "1.&*".check()
        "1.&**".check()
        "1.~(2)".check()
        "1.~(2) do\nend".check()
        "1.+ do\nend".check()
        "1.[](2) do\nend".check()
        "1.[]=".check()
        "1.+(a: 2)".check()
        "1.+(&block)".check()
        "1.//(2, a: 3)".check()
        "1.//(2, &block)".check()
        "{% verbatim do %}\n  1{{ 2 }}\n  3{{ 4 }}\n{% end %}".check()
        "{% for foo in bar %}\n  {{ if true\n  foo\n  bar\nend }}\n{% end %}".check()
        "macro foo\n{% verbatim do %}1{% end %}\nend".check()
        CstAssign("x".variable, CstExpressions(listOf(1.int32, 2.int32))).check("x = (1\n2\n)")
        "asm(\"nop\" ::::)".check()
        "asm(\"nop\" : \"a\"(1), \"b\"(2) : \"c\"(3), \"d\"(4) : \"e\", \"f\" : \"volatile\", \"alignstack\", \"intel\")".check()
        "asm(\"nop\" :: \"c\"(3), \"d\"(4) ::)".check()
        "asm(\"nop\" :::: \"volatile\")".check()
        "asm(\"nop\" :: \"a\"(1) :: \"volatile\")".check()
        "asm(\"nop\" ::: \"e\" : \"volatile\")".check()
        "asm(\"bl trap\" :::: \"unwind\")".check()
        "(1..)".check()
        "..3".check()
        "offsetof(Foo, @bar)".check()
        "def foo(**options, &block)\nend".check()
        "macro foo\n  123\nend".check()
        "if true\n(  1)\nend".check()
        "begin\n(  1)\nrescue\nend".check()
        "他.说(\"你好\")".check()
        "他.说 = \"你好\"".check()
        "あ.い, う.え.お = 1, 2".check()
        "-> : Int32 do\nend".check()
        "->(x : Int32, y : Bool) : Char do\n  'a'\nend".check()
        "->::foo(Int32, String)".check()
        "->::Foo::Bar.foo".check()
        "yield(1)".check()
        "def foo\n  yield\nend".check("def foo(&)\n  yield\nend")
        "def foo(x)\n  yield\nend".check("def foo(x, &)\n  yield\nend")
        "def foo(**x)\n  yield\nend".check("def foo(**x, &)\n  yield\nend")
        "macro foo(x)\n  yield\nend".check()
        "foo { |(x, y)| x }".check(
            """
              foo do |(x, y)|
                x
              end
            """.trimIndent()
        )
        "foo { |(x, (y, z))| x }".check(
            """
              foo do |(x, (y, z))|
                x
              end
            """.trimIndent()
        )
        "\"\\e\\0\\\"\"".check("\"\\e\\u0000\\\"\"")
        "\"#{1}\\0\"".check("\"#{1}\\u0000\"")
        "%r{\\/\\0}".check("/\\/\\0/")
        "%r{#{1}\\/\\0}".check("/#{1}\\/\\0/")
        "`\\n\\0`".check("`\\n\\u0000`")
        "`#{1}\\n\\0`".check("`#{1}\\n\\u0000`")
    }
}